## Лектор
Егор Суворов ([t.me/yeputons](https://t.me/yeputons), [egor_suvorov@mail.ru](mailto:egor_suvorov@mail.ru))

* Веду годовой курс по C++ на ПМИ питерской Вышки ([spb.hse.ru/ba/appmath](https://spb.hse.ru/ba/appmath))
* Сам участвовал во Всероссийской олимпиаде школьников по информатике десяток лет назад.
  * Кстати, участникам олимпиады настоятельно рекомендую отдохнуть от алгоритмов и собраться с силами.
  * Если же лекция по C++ — отдых, здорово.

---

## Лекция

* Про некоторые фишки современного C++17 (и немножко 20), возможно, для олимпиад.
  * К сожалению, эти стандарты поддерживаются пока не везде, но вот C++14 уже довольно распространён.
* Про C++, надо уметь:
  * Переменные, циклы, массивы, функции...
  * `std::vector`, `std::map`, `std::string`...
* Не будем использовать:
  * `int *x = malloc(sizeof(int) * 4);`
  * `int *x = new int[10];`
  * `printf`, `scanf`
  * move-семантику
* Иногда будут всплывать странные конструкции и слова вроде `explicit` и `constexpr`, если они нужны для каких-то полезных мелочей.
  Рассказать на этой лекции не успею (всё-таки не годовой курс), на понимание влиять не должно, поищите сами.
* Темп лекции высокий и она не интерактивная: ставьте на паузу и записывайте себе таймкоды, чтобы задать вопрос мне:
  можно в Телеграм, можно на почту, а можно спросить лично на встрече с представителями питерской Вышки.
* Готовый компилирующийся исходный код можно посмотреть по ссылке на GitHub, которую мы постараемся прикрепить к этому видео:
  [github.com/yeputons/2021-april-roi](https://github.com/yeputons/2021-april-roi)

---
В языке C++ важно понимать, какой код действительно корректен, а не просто случайно заработал
из-за неопределённого поведения (undefined behavior).
Например, так бывает при выходе за границу массива.

* Некоторые ориентируются на компилятор и отладочные режимы (`_GLIBCXX_DEBUG`). "У меня всё работает" — первое приближение, многие компиляторы добавляют свои фишки в язык
  * Прямо сейчас на первом курсе есть ситуации, когда решение почти корректно: не работает "всего" на одном из девяти режимов компиляции.
* Стандарты C++, в основном C++17 и C++20
* Можно прочитать в дружелюбном виде в справочнике [cppreference.com](https://cppreference.com])
  * Не путать с cplusplus.com или C++ Tutorials (ошибки, неточности, меньше деталей).
  * Например, можно узнать, как именно работает range-based-for и как его сделать для своего контейнера.
* Больше текста: ISO C++ FAQ: [isocpp.org/wiki/faq](isocpp.org/wiki/faq)
* Доклады на конференциях CppCon (особенно серия back to basics), C++ Russia
* Для расшифровки синтаксического сахара (вроде `auto`): [cppinsights.io](https://cppinsights.io/)

Обратите внимание: почти всё на английском.
Если вы думаете, какой язык изучать: C++, Python или Rust, изучайте технический письменный английский.
Документация нужна постоянно.

<!--
Начнём лекцию с небольшой разминки: я покажу несколько конструкций C++.
## Range-based-for + structured binding
```c++
#include <map>
#include <string>
#include <iostream>
using namespace std;

int main() {
    map<int, string> m{  // (1)
        {2, "world"},
        {1, "hello"}
    };
    for (
        const auto &  // (4)
        [key, value]  // (3)
        :  // (2)
        m
    ) {
        cout << key << " " << value << "\n";
    }
}
// 1 hello
// 2 world
```

## Избавление от `#define`
```c++
#define N 100 + 1           // было
int x = 2 * N;              // беда :(
int x = 2 * 100 + 1;        // причина беды
constexpr int N = 100'000;  // стало (апостроф из C++14)

#define vi vector<int>   // было
using vi = vector<int>;  // стало (type alias, C++11)

#define vec vector                           // было
template<typename T> using vec = vector<T>;  // стало (alias template, C++11)

// можно даже так
template<typename T> using vp = vector<pair<T, T>>;
vp<int> ~~ vector<pair<int, int>>
```

## Единообразная работа с массивами (C++17)
```c++
int a[10];
vector<int> b(10);

// было
sort(a, a + 10);
sort(b.begin(), b.end());
cout << 10 << "\n";
cout << b.size() << "\n";

// стало
sort(begin(a), end(a));
sort(begin(b), end(b));
cout << size(a) << "\n";
cout << size(b) << "\n";
```
-->
