## Шаблоны класса
Финишная прямая: добавим угловые скобочки, ещё больше повысив переиспользуемость.

```c++
template <typename T>  // typename или class, неважно
struct min_stack {
    // механически заменили внизу int на T
    // .first - data, .second - min_prefix
    std::vector<pair<T, T>> data;

    void push(T val) & {  /* .... */ }
    // ....
};
// ....
min_stack<int> s1;
s1.push(10);
s1.push("hello");  // ошибка компиляции
min_stack<string> s2;
s2.push(10);  // ошибка компиляции
s2.push("hello");
cout << s2.min_element() << "\n";  // hello
```

Это называется "шаблон класса", отличается от generic'ов в Java/C#/Kotlin, но для каждого `T` генерируется
и независимо оптимизируется новый код, нет ограничений на `T`.
Это называется статический полиморфизм: код написан один, но его поведение может отличаться
для разных типов, причём это определяется во время компиляции (а не как в Python).

---
## Оптимизация
А теперь полируем.
Так как `string` копировать долго, стоит добавить
передачу по ссылке в нужные методы:

```c++
    // void push(T val) & { /* .... */ }
    void push(const T &val) & { /* .... */ }

    [[nodiscard]] const T &top() const { /* .... */ }

    [[nodiscard]] const T &min_element() const { /* .... */ }
```

Конкретно в данном случае возврат по ссылке безопасен,
но детально мы это разбирать не будем.

---
## Особенности компиляции
```c++
min_stack<FooBar> s1;  // ошибка компиляции: FooBar не существует
```

```c++
struct point { int x, y; };
min_stack<point> s2;  // скомпилируется
s2.push({10, 20});    // ошибка компиляции: непонятно, как сравнивать point.
auto p = s2.top();    // скомпилируется
s2.pop();             // скомпилируется
```

При этом ошибка компиляции, если присмотреться,
возникнет внутри функции `min` в недрах стандартной библиотеки, даже не при его вызове:
он попробует сравнить два `point` при помощи `operator<` и не получатся.

Дело в том, что при объявлении `min_stack` компилятор проверяет только поля,
а каждый метод компилирует только если вы его вызвали.

Это сделано, чтобы можно было, например, просто отключать у
`std::vector` копирование, если хранимый тип не умеет копироваться.

А нам хочется, чтобы ошибка компиляции была сразу при объявлении `s2`.

---
## Ограничения (C++20)
В C++20 для этого можно указать ограничение на шаблон:

```c++
template <typename T>
requires requires(const T &a, const T &b) {
    a < b;
}
struct min_stack {
    // ...
};
```

Обратите внимание, что слово `requires` повторяется дважды:
в первый раз сообщает, что дальше идёт ограничение,
а дальше идёт концепт — само ограничение — как будто бы функция, начинающаяся со слова `requires`.

Важно тут вызвать как можно более простые операции: `operator<`, а не `std::min`.
Компилятор не будет на самом деле компилировать код целиком,
он посмотрит поверхностно.

```c++
min_stack<point> s2;  // ошибка компиляции
```

На соревнованиях C++20 пока, увы, не поддерживается.
