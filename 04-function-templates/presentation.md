## Шаблоны функций
Теперь осталось разобраться с функцией `print`.

```c++
void print(const min_stack<int> &s) {
    cout << s.top() << " " << s.min_element() << "\n";
}
```

Хочется, чтобы она работала с любым стэком.
Делается так же, как и для классов:

```c++
template <typename T>
void print(const min_stack<T> &s) {
    cout << s.top() << " " << s.min_element() << "\n";
}
```

---
## Автовывод параметров шаблона у функций
Дальше при вызове компилятор автоматически догадается, чему равно `T`,
решив уравнение относительно типа аргумента:

```c++
my_stack<int> s1;
s1.push(10);
print(s1);       // T = int
print<int>(s1);  // можно указать явно

my_stack<string> s2;
s2.push("hello");
print(s2);          // T = string
print<string>(s2);  // можно указать явно
print<int>(s2);     // ошибка компиляции

print(10);  // T = ???, ошибка компиляции
```

```c++
// CTAD (Class Template Argument Deduction), начиная с C++17.
vector v{1, 2, 3};  // надо сразу проинициализировать
```

Можно сделать и для своих классов, но мы туда углубляться не будем.
Сайт [cppinsights.io](https://cppinsights.io/) поможет увидеть все автовыведенные типы.

---
## Особенности компиляции
Шаблоны функций компилируются так же лениво, как и шаблоны классов.
Пока не вызовешь — не скомпилируется.

```c++
template <typename T>
void print(const min_stack<T> &s) {
    cout << s.toppp() << " " << s.min_element() << "\n";
}
```

Это не будет ошибкой компиляции, пока не вызовем и не обнаружится,
что у конкретного `min_stack<int>` нет метода `toppp()`.

Причина: строго говоря, можно сделать разные методы у `min_stack<int>`
и `min_stack<string>`, это называется "специализация шаблонов", но мы туда не лезем.

---
## Обобщённое программирование
```c++
template <typename Container>
auto sum_all(const Container &c) {  // возвращаемый тип выведем автоматически
    auto res = 0;  // выведется в int!
    for (const auto &val : c) {
        res += val;
    }
    return res;
}
// ....
sum_all(vector{1, 2, 3, 4})  // 0 + 1 + 2 + 3 + 4 == 10
sum_all(vector{1.75, 2.75})  // 0 + (int) 1.75 + (int) 2.75 == 3
sum_all(set{1, 1, 4})        // 0 + 1 + 4 == 5
```

Другая задача.
Попробуем просуммировать все элементы в каком-нибудь контейнере (как это делает функция `accumulate`).

Можно было бы сделать `sum_all` только для вектора и узнать тип,
но мы же на самом деле тип можем получить и из контейнера.

---
## Вспомогательные типы
```c++
template <typename Container>
auto sum_all(const Container &c) {
    typename Container::value_type res{};
    for (const auto &val : c) {
        res += val;
    }
    return res;
}
// ....
sum_all(vector{1, 2, 3, 4})  // 0 + 1 + 2 + 3 + 4 == 10
sum_all(vector{1.75, 2.75})  // 0 + 1.75 + 2.75 == 4.5
sum_all(set{1, 1, 4})        // 0 + 1 + 4 == 5
```

Это уже вполне себе метапрограммирование: рассказываем компилятору,
как написать за нас нужную функцию.
Это, кстати, уже круче встроенного `accumulate`,
но мы предполагаем что-то про значение по умолчанию.

На самом деле можно получить тип элемента и без помощи от контейнера, но требуются продвинутые техники:

* `decltype(*c.begin())`
* `std::remove_reference_t<>`
* `std::remove_cv_t<>`/`std::remove_const_t<>`
