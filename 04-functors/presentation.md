## Функторы
Теперь давайте займёмся функторами.
Но не теми, который в функциональном программировании.

Функтор в C++ это — это обобщении функции.
Это некоторый объект, после которого можно написать круглые скобки
и "вызвать" его.
В частности, любая функция является функтором:

```c++
bool check1(int a, int b) {
    return a > b;
}
// ....
check1(10,  5)  // true
check1(10, 15)  // false

vector v{1, 2, 3};
sort(begin(v), end(v), check1);
// v == {3, 2, 1}
```

---
## Объекты-функторы
Функциями дело не ограничивается.
Переменные тоже могут быть функторами.
Для этого нужно, чтобы у их типа был специальный метод с названием `operator()`.
Это называется "перегрузка оператора":

```c++
struct Checker {
    bool operator()(int a, int b) {  // operator() — имя метода.
        return a > b;
    }
};
// ....
Checker check2;
check2(10,  5)  // true
check2(10, 15)  // false

vector v{1, 2, 3};
sort(begin(v), end(v), check2);
// v == {3, 2, 1}
```

Пока что выглядит не очень полезно: могли завести обычную функцию.

---
## Добавляем состояние
Функциональные объекты оказываются полезными, потому что у них можно завести поля,
которые можно динамически инициализировать:

```c++
struct Checker {
    int center;
    bool operator()(int a, int b) {
        return abs(a - center) < abs(b - center);
    }
};
// ....
Checker check3;
cin >> check3.center;

vector v{1, 2, 3}
sort(begin(v), end(v), check3);
// v отсортирован по расстоянию до считанного check3.center
```

Причём `Checker` — это обычный тип.
Можем создать хоть `vector<Checker>`, все элементы которого ведут себя по-разному.

С функциями так нельзя: все функции должны быть созданы до компиляции.

---
## Использование функторов
Функторы можно передавать не только в функции вроде `sort`, но и в контейнеры:

```c++
struct Checker {
    int center;
    bool operator()(int a, int b) const {  // !
        return abs(a - center) < abs(b - center);
    }
};
// ....
Checker check4{5};  // check4.center == 5
set<int, Checker> s1({1, 2, 3}, check4);  // копирование
// s1 == {3, 2, 1}

check4.center = 2;
set<int, Checker> s2({1, 2, 3}, check4);  // копирование
// s2 = {2, 1}

s1.insert(4);  // s1 == {4, 3, 2, 1}
s2.insert(4);  // s2 == {2, 1, 4}
```

Единственная тонкость: `set` жёстко требует, чтобы компаратор
не мог измениться в процессе работы.
Это разумное требование для любого компаратора, поэтому `const`
стоило добавить раньше, хоть `sort` его и не требует.
