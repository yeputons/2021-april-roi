## Функторы
Теперь давайте займёмся функторами.
Но не теми, который в функциональном программировании.

Функтор в C++ это — это обобщении функции.
Это некоторый объект, после которого можно написать круглые скобки
и "вызвать" его.
В частности, любая функция является функтором:

```c++
bool check1(int a, int b) {
    return a > b;
}
// ....
check1(10,  5)  // true
check1(10, 15)  // false

vector v{1, 2, 3};  // <int> выводится в C++17 автоматически.
sort(begin(v), end(v), check1);
// v == {3, 2, 1}
```

---
## Объекты-функторы
Функциями дело не ограничивается.
Переменные тоже могут быть функторами.
Для этого нужно, чтобы у них был метод `operator()`
("перегрузка оператора"):

```c++
struct Greater {
    bool operator()(int a, int b) {  // operator() — имя метода.
        return a > b;
    }
};
// ....
Greater check2;
check2(10,  5)  // true
check2(10, 15)  // false

vector v{1, 2, 3};
sort(begin(v), end(v), check2);
// v == {3, 2, 1}
```

Пока что выглядит не очень полезно: могли завести обычную функцию.
Разве что для `set` есть какая-то польза: можно указать компаратор
в угловых скобках.

```c++
set<int, less<int>> s1{1, 2, 3};     // {1, 2, 3}
set<int, greater<int>> s2{1, 2, 3};  // {3, 2, 1}
```

---
## Добавляем состояние
Функциональные объекты оказываются полезными, потому что у них можно завести поля,
которые можно динамически инициализировать:

```c++
struct CloserToCenter {
    int center;
    bool operator()(int a, int b) {
        return abs(a - center) < abs(b - center);
    }
};
// ....
CloserToCenter check3;
cin >> check3.center;

vector v{1, 2, 3}
sort(begin(v), end(v), check3);
// v отсортирован по расстоянию до считанного check3.center
```

Причём `CloserToCenter` — это обычный тип.
Можем создать хоть `vector<CloserToCenter>`, все элементы которого ведут себя по-разному.

С функциями так нельзя: все функции должны быть созданы до компиляции.

---
## Использование функторов
Функторы с состоянием можно передавать не только в функции вроде `sort`, но и в контейнеры:

```c++
struct CloserToCenter {
    int center;
    bool operator()(int a, int b) const {  // !
        return abs(a - center) < abs(b - center);
    }
};
// ....
CloserToCenter check4{5};                        // check4.center == 5
set<int, CloserToCenter> s1({1, 2, 3}, check4);  // копирование
// s1 == {3, 2, 1}

check4.center = 2;
set<int, CloserToCenter> s2({1, 2, 3}, check4);  // копирование
// s2 = {2, 1}

s1.insert(4);  // s1 == {4, 3, 2, 1}
s2.insert(4);  // s2 == {2, 1, 4}
```

Единственная тонкость: `set` жёстко требует, чтобы компаратор
не мог измениться в процессе работы.
Это разумное требование для любого компаратора, поэтому `const`
стоило добавить раньше, хоть `sort` его и не требует.
