## Лямбда-выражения
Наконец, можно посмотреть появившиеся в стандарте C++11 лямбда-выражения
(ещё называются лямбда-функциями, анонимными/неименованными/безымянными функциями).
Вы могли их видеть в таких примерах:

```c++
int center = 5;
vector v{1, 2, 3};
sort(begin(v), end(v),
    [&](int a, int b) {
        return abs(a - center) < abs(b - center);
    }
    // Python: lambda a, b: abs(a - center) < abs(b - center)
);
```

Лямбда-выражения — это конструкция на три строчки между первой квадратной квадратной скобкой
и последней фигурной.
Она создаёт новую структуру, у которой есть `operator()` реализованный так,
как мы написали.
То есть сравнивающий два своих параметра по расстоянию до `center`.
Внутри квадратных скобок мы указываем __захваты__ — какие локальные
переменные будут доступны для нашего `operator()`.
`&` означает "все, которые используются", прямо как в Python.

---
## Эквивалент лямбда-выражения
То есть на самом деле лямбда-выражение переписывается вот так:

```c++
int center = 5;
vector v{1, 2, 3};
struct lambda_239 {  // новая структура, её имя получить невозможно
    int &center;  // ссылка на локальную переменную
    bool operator()(int a, int b) const {  // bool автоматически, const автоматически
        return abs(a - center) < abs(b - center);
    }
};
sort(begin(v), end(v), lambda_239{center});
```

Если вам хочется разобраться на более сложных лямбдах — рекомендую
сайт [cppinsights.io](https://cppinsights.io/), который разворачивает
некоторые конструкции C++ так, как я показал на слайдах.

Там окажется, что внутри лямбды, на самом деле, есть ещё немного
вспомогательных вещей, но эти детали мы пропустим.

---
## Сохранение лямбды
Так как лямбда-выражение возвращает объект, его можно записать в переменную.
Например, так мы можем сделать себе что-то вроде "локальной функции".
Правда, тип переменной мы назвать не сможем, придётся использовать слово `auto`:

```c++
int a = 10, b = 20, c = 30;
auto print_all = [&]() {
    cout << "a=" << a << ", b=" << b << ", c=" << c << "\n";
};
print_all();  // a=10, b=20, c=30
a = 50;
print_all();  // a=50, b=20, c=30
```

Переприсвоить эту переменную тоже не получится, рекурсия не поддерживается:

```c++
auto fib = [&](int n) {
    if (n <= 1) return n;
    // ошибка компиляции: захватить fib нельзя, так как
    // тип fib зависит от того, что захватит лямбда
    return fib(n - 1) + fib(n - 2);
};

```

---
## Другие виды захватов
```c++
int a = 10, b = 20;
vector v{1, 2, 3};
auto print_ab_inc_a = [&a, &b]() {
    cout << a << " " << b << "\n";  // ок, a и b захвачена
    a++;                            // можно менять
    cout << v.size() << "\n";       // ошибка компиляции: v не захвачен
};
auto print_10 = [a]() {
    cout << a << "\n";  // всегда 10, в Python так не получится
    a++;                // менять нельзя, operator() const
};
auto print_10_20 = [=]() {          // то же самое, что [a, b]
    cout << a << " " << b << "\n";  // всегда 10 20
    // cout << v.size() << "\n";    // сделает захват [a, b, v], v скопируется
};
print_ab_inc_a();   // 10 20
cout << a << "\n";  // 11
a += 100;           // a = 111
print_ab_inc_a();   // 111 20
print_10();         // 10
print_10_20();      // 10 20
```

---
## Захваты произвольных выражений (C++14)
```c++
int a = 10, b = 20;
vector v{1, 2, 3};
auto print_a_23_inc_a = [&x = a, y = b + v.size()]() {
    cout << x << " " << y << "\n";  // значение a и 23
    x++;                            // можно менять, изменится a
    y++;                            // менять нельзя
};
// можно использовать для эмуляции захвата по константной ссылке (C++17)
auto print_v = [&v = as_const(v)] {       // v не копируется
    cout << v[0] << " " << v[1] << "\n";  // значения из v
    v = {};                               // нельзя случайно поменять
};
print_a_23_inc_a();  // 10 23
cout << a << "\n";   // 11
print_v();           // 1 2

a += 100;              // a = 111
v = {-1, -2, -3, -4};  // v = {-1, -2, ....}
print_a_23_inc_a();    // 111 23
cout << a << "\n";     // 112
print_v();             // -1 -2
```

---
## Смешанные захваты
```c++
int a = 10, b = 20;
vector v{1, 2, 3};
auto f1 = [=, &v]() {              // [a, &v]
    cout << a << " " << v.size();  // ок
    v = {};                        // ок
    a++;                           // ошибка компиляции
};
auto f2 = [=, &v = as_const(v)]() {  // [a, &cv = as_const(v)]
    cout << a << " " << v.size();    // ок
    a++;                             // ошибка компиляции
    v = {};                          // ошибка компиляции
};
auto f3 = [&, b, &v = as_const(v)]() {  // [&a, b, &v = as_const(v)]
    cout << a << " " << v.size();       // ок
    a++;                                // ок
    b++;                                // ошибка компиляции
    v = {};                             // ошибка компиляции
};
```
