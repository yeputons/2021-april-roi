## Immediately Invoked Function Expression (IIFE)
Теперь давайте посмотрим, как можно применять функторы и лямбда-выражения в частности для повышения надёжности кода или упрощения.

```c++
int arr[] = {2, 3, 4, 5};
constexpr int n = size(arr);
// до
int a = -1, b = -1;
for (int i = 0; i < n && a == -1; i++)
    for (int j = 0; j < n && a == -1; j++)
        if (i != j && arr[i] % arr[j] == 0)
            a = i, b = j;
// после
const auto [a, b] =  // можно сделать переменные константными
    [&]() {  // создали функтор при помощи лямбда-выражения
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                if (i != j && arr[i] % arr[j] == 0)
                    return pair{i, j};  // не нужны флаги
        return pair{-1, -1};  // не нужны промежуточные переменные
    }();
```
Обычные функторы и функции вызываются сотни миллионов раз в секунду,
без разницы для оптимизатора.

---
## Стирание типов (type erasure)
Мы не можем так просто положить функторы разных типов в один массив:

```c++
vector</* ??? */> v{
    [x = 10](int y) { cout << x + y << "\n"; },
    [x = 20](int y) { cout << x + y << "\n"; }
};
```

Напоминаю, что каждое лямбда-выражение генерирует отдельный тип.

Но можем завернуть каждый функтор в обёртку, которая позволит
компилятору "забыть" про реальный тип функтора.
```c++
vector<function<void(int)>> v{
    [x = 10](int y) { cout << x + y << "\n"; },
    [x = 20](int y) { cout << x + y << "\n"; }
};
for (const auto &f : v) {
    f(5);  // 15, 25
}
```
Это медленно: несколько десятков миллионов в секунду и
оптимизатор не видит сквозь `function`, не может встроить функцию.

---
## Функтор как параметр функции
Следующее.
Произвольные функторы можно очень эффективно передавать как параметры функций при помощи шаблонов.

```c++
template<typename Fn>
void call_10_20_30(Fn fn) {
    fn(10);
    fn(20);
    fn(30);
}
// ....
call_10_20_30([](int x) {  // 10, 20, 30
    cout << x << "\n";
});
```

Всё оптимизируется и инлайнится!

Можно добавить ограничений из C++20 и концепт `invocable`, чтобы ошибки компиляции стали проще.

<!--
## Ограничения (C++20)
Так как это шаблон, ошибки компиляции будут странные и длинные.
По одной на каждый вызов `fn`:
```c++
call_10_20_30([](){});  // три ошибки компиляции
```

Можно добавить ограничение, и в языке даже есть встроенный концепт `invocable`

```c++
template<typename Fn>
requires invocable<Fn, int>
void call_10_20_30(Fn fn) {
    fn(10);
    fn(20);
    fn(30);
}
// ....
call_10_20_30([](int x) {  // 10, 20, 30
    cout << x << "\n";
});
call_10_20_30([](){});  // одна ошибка компиляции
```

## Короткие ограничения (C++20)
Или, что то же самое:
```c++
template<invocable<int> Fn>  // заменили typename на концепт
void call_10_20_30(Fn fn) {
// или
void call_10_20_30(invocable<int> auto fn) {
    fn(10);
    fn(20);
    fn(30);
}
// ....
call_10_20_30([](int x) {  // 10, 20, 30
    cout << x << "\n";
});
call_10_20_30([](){});  // одна ошибка компиляции
```

Здесь `auto` — это синтаксический сахар для шаблонов.
На самом деле функция `call_10_20_30` всё ещё шаблонная.

Можно просто `auto`, без `invocable<int>`, будет шаблон без ограничений.

## Шаблонные лямбда-выражения (C++14)
```c++
[](const auto &f) {
    return f(10);
}
// эквивалентно
struct lambda_240 {
    template<typename F>
    auto operator()(const F &f) const {
        return x + y;
    }
};
```

Сама структура не шаблонная. Шаблонный у неё только метод.

Зачем передавать функтор в качестве параметра лямбда-функции вы, возможно, ещё не понимаете,
но как только начинаешь всё это использовать, остановиться невозможно.

-->
---
## Функтор как поле класса
Наконец, научимся хранить функторы в своих классах, как это делает `set<>`.

```c++
template<typename T, typename Compare = less<T>>  // новый параметр шаблона
struct min_stack {
    Compare compare;  // храним функтор как поле, тип берем из шаблона
    // ....
            // data.emplace_back(val, min(val, min_element()));
            data.emplace_back(val, min(val, min_element(), compare));
    // ....
};
template <typename T, typename Compare>
void print(const min_stack<T, Compare> &s) {  // новый параметр шаблона
// ....
min_stack<int> s;  // работает как и раньше
// ....
min_stack<int, greater<int>> s_gr;  // ищет максимум
// ....
min_stack<int, CloserToCenter> s_gr;
s_gr.compare.center = 4;  // ищет точку, ближайшую к 4
```

Всё идеально оптимизируется на этапе компиляции.
Можно добавить ограничения из C++20.

На этом наш `min_stack` закончен.
Так можно писать и любые другие структуры данных,
в которых можно ошибиться.
Например, декартово дерево и дерево отрезков с групповыми операциями
у меня всегда сделаны через классы.
Особенно в задачах, где они лишь вспомогательная структура.
Там я хочу решать задачу и пользоваться красивым интерфейсом
у корректной реализации.
